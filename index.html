<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script src="./js/bootstrap-dropdown.js"></script>
  <script src="./js/bootstrap-scrollspy.js"></script>
  <script src="./js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  <link rel="stylesheet" type="text/css" href="./css/bootstrap.css" />
  <link rel="stylesheet" type="text/css" href="./css/style.css" />
  <link rel="stylesheet" type="text/css" href="./css/zenburn.css" />
  <title>rosnodejs - Program robots with JavaScript</title>
</head>

<body>
<div class="container">

<nav class="topbar" data-dropdown="dropdown" data-scrollspy="scrollspy">
  <div class="topbar-inner">
    <div class="container">
      <a class="brand" href="#home">rosnodejs</a>
      <ul class="nav">
        <li>
          <a href="#robot_introduction"><img class="nav-icon"
            src="images/robot-light-small.png"/>Intro to Robotics</a>
        </li>
        <li>
          <a href="#rosnodejs_introduction"><img class="nav-icon"
            src="images/js-light-small.png"/>About Rosnodejs</a>
        </li>
        <li class="dropdown" data-scrollspy="scrollspy">
          <a href="#" class="dropdown-toggle"><img class="nav-icon"
            src="images/wrench-light-small.png"/>How to</a>
          <ul class="dropdown-menu"> 
            <li>
              <a href="#install">Install</a>
            </li>
            <li>
              <a href="#how-to-program">Program your robot with JavaScript</a>
            </li>
            <li>
              <a href="#how-to-web-server">Turn your robot into a web server</a>
            </li>
            <li>
              <a href="#how-to-web-app">Create a web app to control your
                robot</a>
            </li>
          </ul>
        </li> 
        <li>
          <a href="https://github.com/baalexander/rosnodejs"><img
            class="nav-icon" src="images/blacktocat-small.png"/>Source</a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<article id="home">
  <div class="row show-grid">
    <p>
      <img src="images/masthead.png" /> 
    </p>
  </div>
  <h1 class="brand">rosnodejs <small>Programming robots with JavaScript</small></h1>
  <div class="row show-grid">
    <p>
      Rosnodejs is a node.js module that let's you use JavaScript to interact
      with the <a href="http://www.ros.org/wiki/ROS/Introduction">Robot
        Operating System</a>, an open-source robot framework used by many of the
      top universities and research programs around the world.
    </p>
    <p>
      Perform a range of robotic tasks, from controlling the motors on an
      Arduino to processing Kinect sensor data using JavaScript and node.js.
    </p>
    <p>
      The goal is to make the field of robotics more accessible to the countless
      intelligent web developers out there.
    </p>
  </div>
  <div class="row">
    <h2>Where to go from here?</h2>
    <div class="row show-grid">
      <div class="span-one-third">
        <h3>Learn about robots</h3>
        <p>
          Read a quick introduction on how to get a robot as well as what's
          involved in programming robots today.
        </p>
        <p>
          <a class="btn" href="#">View details »</a>
        </p>
      </div>
      <div class="span-one-third">
        <h3>Learn about rosnodejs</h3>
        <p>
          If you understand ROS already, read how rosnodejs fits into the
          picture.
        </p>
        <p>
          <a class="btn" href="#">View details »</a>
      </p>
      </div>
      <div class="span-one-third">
        <h3>Learn how to use</h3>
        <p>
          See code examples on creating a rosnodejs project, turning your robot
          into a web server, and creating a telepresence web app.
        </p>
        <p>
          <a class="btn" href="#">View details »</a>
        </p>
      </div>
    </div>
  </div>
</article>

<article id="robot_introdution">
  <h1>Introduction to Robotics</h1>
  <p>
    Getting involved in robots can be intimidating. But if you're sick of the 2D
    world of web development and want to make something tangible, this is the
    place to start.
  </p>
  <p>
    There are two things you'll probably want to know when starting in robotics:
    How to get a robot and how to program it.
  </p>
  <h3>How to get a robot</h3>
  <p>
    Many of the tutorials from <a
      href="http://www.instructables.com/pages/search/search.jsp?q=build+a+robot">Instructables</a>
    or a <a href="https://www.google.com/search?q=how+to+build+a+robot"> Google
      search</a> provide excellent step-by-step instructions on creating a basic
    moving robot that can do something simple, like avoid a wall.
  </p>
  <p>
    Unfortunately, most of these robots are not powerful enough to run the
    latest robot algorithms, like processing Kinect data to map the environment.
    A computer is usually needed for these tasks.  This performance requirement
    leaves a couple options: building a basic robot from one of the tutorials
    and connecting a computer to it or buying a robot platform.
  </p>
  <p>
    Since the Robot Operating System (ROS) &mdash; discussed in the next section
    &mdash; supports <a
      href="http://www.ros.org/wiki/rosserial_arduino">interfacing with the
      Arduino</a>, a cheaper <a href="http://arduino.cc">Arduino
      microcontroller</a> robot could be connected to a computer and offload the
    computing to the ROS platform.
  </p>
  <p>
    For those not interested in mucking around with circuits and hardware, the
    <a href="http://www.turtlebot.com/">TurtleBot</a> makes for a complete robot
    platform ready to program. It's basically a Roomba, Kinect, and computer
    nicely packaged together. The advantage of using a standardized robot
    platform is the community support. For example, rosnodejs has been tested on
    the TurtleBot platform.
  </p>
  <p>
    The key decision you need to make is build or buy a robot. Just remember
    that if your goal is to run something like ROS and rosnodejs, you'll need a
    computer for the robot.
  </p>
  <h3>How to program it</h3>
  <p>
    One of the top frameworks to program robots with today is the <a
      href="http://ros.org">Robot Operating System</a> (ROS). The beauty of ROS
    lies in its decoupled architecture. Everything is a node and nodes
    communicate by publishing and subscribing to messages.
  </p>
  <p>
    An example should clarify:
  </p>
  <p>
    Let's say there's a node dedicated to processing Kinect sensor data.  The
    node publishes a message type containing image and depth information.
    Another node would listen for this message type and interpret the 3D data.
    The interpreting node could notice there's a wall coming up and publish a
    direction message type saying move back.  Finally, there's a node &mdash;
    perhaps running on an Arduino &mdash; subscribing to direction message
    types.  The node receives the message with directions to move back and
    rotates its motors backwards.
  </p>
  <p>
    The decoupling design has a couple distinct advantages.
  </p>
  <p>
    One advantage is that any part of the robot can be replaced. For example, a
    Kinect sensor may be replaced with a newer sensor. As long as this sensor
    publishes the same message type, none of the other nodes will notice a
    difference.
  </p>
  <p>
    Another important advantage of decoupling and open-source is that anyone can
    contribute a node or a package of nodes. A team at one company may actively
    be working on nodes related to the Kinect while another team at a university
    is creating a stack for the Arduino.  There's hundreds of packages in the
    ROS ecosystem that will perform many robotic operations for you. And most of
    these packages are open-source for you to contribute back to.
  </p>
  <p>
    Now, how to get started?
  </p>
  <p>
    The <a href="http://ros.org">documentation on ros.org</a> is actually quite
    extensive, up-to-date, and usually written with few assumptions of prior
    experience.
  </p>
  <p>
    The <a href="http://www.ros.org/wiki/ROS/Tutorials">Beginner Level
      Tutorials</a> are an exceptional source, walking you through everything
    from installing ROS to making your first package and node.  These tutorials
    are the best way to get started.
  </p>
  <p>
    If you follow the tutorials, you'll notice the code samples are in Python or
    C++. That's because there's a ROS client library for Python and a client
    library for C++. A client library is a set of libraries for a language that
    enables use of that language to interact with ROS.  Rosnodejs is a client
    library for JavaScript.
  </p>
</article>

<article id="rosnodejs_introdution">
  <h1>About rosnodejs</h1>
  <p>
    Rosnodejs is a JavaScript <a
      href="http://www.ros.org/wiki/Client%20Libraries">client library</a> for
    ROS, which means you can make a Node.js module that interacts with ROS.
    Rosnodejs is an <a href="http://npmjs.org">NPM module</a> and can be
    installed and required like any other NPM module.
  </p>
  <p>
    Why use rosnodejs over the excellent Python and C++ client libraries?
  </p>
  <p>
    A few reasons include:
  </p>
  <ul>
    <li>
      HTTP/TCP/UDP performance. Node.js has strong built-in support for HTTP,
      TCP, and UDP, the basic transport layers used by the Robot Operating
      System.
    </li>
    <li>
      The rapidly growing Node.js ecosystem. Many libraries like Socket.IO have
      strong first party support for Node.js
    </li>
    <li>
      Familiarity. Robots are hard enough, write code in what you know.
    </li>
  </ul>
  <p>
    The big reason to use rosnodejs, however, is when using the web browser.
    While rosnodejs runs natively on the robot using Node.js, all the core ROS
    constructs like Node, Publisher, and Subscriber can run natively in the
    browser. Yep, being cross platform means you can write your ROS code to run
    in the browser just as easily as running natively on the robot itself. No
    plug-ins required.
  </p>
  <h3>Related projects</h3>
  <p>
    A couple of projects are available for different uses of rosnodejs.
  </p>
  <p>
    <a href="https://github.com/baalexander/rosmsgjs">rosmsgjs</a> - Generates a
    file representing all the message definitions for a package.  These message
    types extend Backbone.js models for easier integration in web apps.
  </p>
  <p>
    <a href="https://github.com/baalexander/rosserverjs">rosserverjs</a> - Turns
    your robot into a web server. Provides an Express server to build whatever
    web app desired. Serves the necessary message definition files as well as
    the cross platform rosnodejs library.
  </p>
  <p>
    The <a href="#how-to">How To sections</a> provide code examples on using
    rosnodejs natively on the robot, generating JavaScript files for the message
    definitions, turning your robot into a web server, and running ROS code in
    the browser.
  </p>
</article>

<article id="install">
  <h1>How to install</h1>
  <p>
    Before rosnodejs can be installed, node.js and ROS need to be set
    up on the machine first.
  </p>
  <ul>
    <li>
      <a href="http://nodejs.org/#download">Install Node.js and NPM</a> (0.6+
      and 1.0+)
    </li>
    <li>
      <a href="http://www.ros.org/wiki/ROS/Installation">Install ROS</a>
      (Electric Emys+)
    </li>
  </ul>
  <p>
    Rosnodejs is an NPM module. Simply create a directory for the project
    (which will act as a <a href="http://www.ros.org/wiki/Packages">ROS
      package</a>) and install rosnodejs with <code>npm install
      rosnodejs</code> in that directory.
  </p>
  <p>
    ROS nodes can then be created as node.js modules, using <code>var ros =
      require('rosnodejs')</code>.
  </p>
</article>

<article id="how-to-program">
  <section class="suite">
    <h1>How to use rosnodejs</h1>
    <dl>
    <dt>create a package</dt>
    <dd><pre><code class="javascript">
// After installing ROS, creating a new rosnodejs project is similar to creating
// any new ROS package.

// For more information:
//  * ROS packages - http://www.ros.org/wiki/ROS/Tutorials/CreatingPackage
    </code></pre></dd>
    <dt>create a node</dt>
    <dd><pre><code class="javascript">
// The Robot Operating System is a graph of nodes. Each node is programmed
// to perform a task. For example, a node may transmit sensor data from a
// Kinect (publish a message) while another node listens for Kinect sensor
// data (subscribes to the messages) and processes that data.
//
// Almost all actions performed with rosnodejs will begin by creating a ROS
// node. These nodes can later be customized to publish or subscribe to
// messages over topics and then do something interesting with the data.
//
// For more information:
//  * http://www.ros.org/wiki/ROS/Tutorials/UnderstandingNodes

// Create a node named 'talker' and registers it with ROS Master. ROS Master
// is the central authority for keeping track of all the nodes in the graph
// and helps connect the other nodes so they can talk to each other.
ros.createNode({ name: 'talker' }, function(error, node) {
// On successfully registering the node, the node object is returned.
node.should.be.an.instanceof(ros.Node)

// Node attributes can be retrieved with get().
node.get('name').should.equal('talker')

// A node contains a collection of publishers and subscribers. A publisher
// sends messages for a topic. A subscriber listens to messages for a
// given topic. The 'talking to' and 'listening to other node' examples go
// into more detail about publishers and subscribers.
node.publishers.length.should.equal(0)
node.subscribers.length.should.equal(0)

done(error)
})</code></pre></dd>
    <dt>create a message</dt>
    <dd><pre><code>
// The message is one of the fundamental medium for nodes to communicate
// with each other in ROS.
//
// A message is derived from a message type, a defined set of data types the
// message will contain. The message type to message relation can be
// considered similar to the class to object relation.
//
// A ROS package will usually define a set of message types. For example,
// the std_msgs package defines message types for a set of basic data types,
// like std_msgs/String and std_msgs/Int32.
//
// To make things easier, rosnodejs provides a JavaScript model for
// representing message objects. Rosnodejs handles serializing and
// deserializing these messages for communicating with other nodes.
//
// The rosmsgjs project creates JavaScript files containing all the message
// types for a given package.
//
// For more information:
//  * http://www.ros.org/wiki/msg
//  * https://github.com/baalexander/rosmsgjs

// Std_msgs is a JavaScript module containing JavaScript objects for all the
// message types in the std_msgs package. This module was generated from the
// rosmsgjs project.
var message = new std_msgs.String()

// All messages extend the Message object.
message.should.be.an.instanceof(ros.Message)

// A message's attributes are accessed with set() and get(). The attribute
// names correspond to the field names from the message type definition.
message.set({ data: 'A robot may not injure a human being.' })
message.get('data').should.equal('A robot may not injure a human being.')

// All messages have the 'type' property and 'md5sum' property to identify
// the message type.
// The type property is the message type.
message.get('type').should.equal('std_msgs/String')
// The MD5 sum is the hash of the message fields to verify with other nodes
// that this is the correction version of the message type.
message.get('md5sum').should.equal('992ce8a1687cec8c8bd883ec73ca41d1')</code></pre></dd>
    <dt>talk to other nodes</dt>
    <dd><pre><code>
// A node talks to other nodes by publishing messages for a topic. The nodes
// interested in the messages subscribe to the same topic. A node that
// publishes messages for a topic is known as a publisher for that topic. A
// node can be a publisher for one or many topics.
//
// In rosnodejs, a node creates a publisher for each topic it wants to
// publish on.
//
// Behind the scenes, a node declares itself as a publisher for a topic by
// registering itself as a publisher for the topic with ROS Master. ROS
// Master keeps track of what topic every node is publishing or subscribing
// to and helps them communicate with one another.

// The 'keyboard' node will be the node publishing messages.
ros.createNode({ name: 'keyboard' }, function(error, node) {

// This node will tell a robot to move forward by publishing the
// directions.
//
// A publisher requires two pieces of information to register itself with
// ROS Master:
//  * The topic the messages will be published for (a string value)
//  * And the message type of the messages being published.
var publisherParams = {
// 'cmd_vel' is a common topic used for giving directions to a robot. A
// publisher for the 'cmd_vel' topic could be a keyboard node, listening
// to arrow key events and converting those to movement directions.
topic:   'cmd_vel'
// A common message type for movement directions is geometry_msgs/Twist.
// The message type contains the information for linear directions and
// turns.
, Message: geometry_msgs.Twist
}

// The node registers itself as a publisher for the 'cmd_vel' topic,
// saying it will publish messages of the geometry_msgs/Twist type.
node.createPublisher(publisherParams, function(error, publisher) {

// On successfully registering the publisher with ROS Master, the
// publisher object is returned.
publisher.should.be.an.instanceof(ros.Publisher)

// The movement direction being published tells the robot to move
// forward with a speed of 1.
//
// Geometry_msgs/Twist has two fields, linear and angular, which happen
// to be messages themselves of type geometry_msgs/Vector3.
var message = new geometry_msgs.Twist()
message.set({
linear: {
x: 1.0
, y: 0.0
, z: 0.0
}
, angular: {
x: 0.0
, y: 0.0
, z: 0.0
}
})

// Publishes the message. This will broadcast the movement directions to
// whatever nodes are subscribing to the 'cmd_vel' topic. The beauty of
// ROS is that the publisher node deciding which direction the robot
// should move is decoupled from the node that actually moves the robot.
publisher.publish(message, function(error) {
done(error)
})
})
})</code></pre></dd>
    <dt>listen to other nodes</dt>
    <dd><pre><code>
// ROS uses a publish/subscribe method for nodes, where a node will publish
// messages on a topic and other nodes can subscribe to that topic to
// receive the messages. A node that subscribes to a topic is knowns as a
// subscriber.
//
// One big advantage of the publish/subscribe method for ROS nodes is the
// subscriber nodes do not need to care where the messages originated. For
// example, a node may subscribe to the sensor_msgs/Range message type of
// topic 'distance_data' to determine if the robot is approaching a wall.
// The node publishing messages to the 'distance_data' topic could be using
// an IR sensor or an ultrasound sensor, but the subscribing node does not
// care, it just needs the distance.
//
// In rosnodejs, a node creates a subscriber for each topic it wants to
// listen to.

// The 'motor' node will be subscribing to movement direction messages.
// While the messages will be generic directions, the 'motor' node will
// interpret the directions and decide how to move the robots motors.
ros.createNode({ name: 'motor' }, function(error, node) {

// A subscriber requires two pieces of information to register itself with
// ROS Master:
//  * The topic the subscriber is interested in (a string value).
//  * And the message type of the messages being subscribed to.
var subscriberParams = {
// 'cmd_vel' is a common topic used for giving directions to a robot.
topic:   'cmd_vel'
// A common message type for movement directions is geometry_msgs/Twist.
, Message: geometry_msgs.Twist
}

// The node registers itself as a subscriber for the 'cmd_vel' topic,
// letting ROS master and other nodes know it is interested in messages of
// the geometry_msgs/Twist type.
node.createSubscriber(subscriberParams, function(error, subscriber) {

// When messages are published for the 'cmd_vel' topic, the callback for
// subscribe() will be called with the message object. This callback
// will be called every time a message is published.
subscriber.subscribe(function(error, message) {

message.get('type').should.equal('geometry_msgs/Twist')

// The geometry_msgs/Twist message type has two fields that are
// message types too: linear and angular.
// The linear field contains linear movement directions for the robot.
var linear = message.get('linear')
linear.get('type').should.equal('geometry_msgs/Vector3')
// A value of 1.0 for linear's x implies the robot should move forward
// at a speed of 1.
linear.get('x').should.equal(1.0)
linear.get('y').should.equal(0.0)
linear.get('z').should.equal(0.0)

// The angular field contains rotational movement directions for the
// robot.
var angular = message.get('angular')
angular.get('type').should.equal('geometry_msgs/Vector3')
angular.get('x').should.equal(0.0)
angular.get('y').should.equal(0.0)
angular.get('z').should.equal(0.0)

// Now that a message is received, it is up to the node on what
// actions to take based on the message data. This 'motor' node could
// read the message's linear.x value of 1.0 and decide to make the
// robot move forward.
//
// More concretely, if an Arduino was controlling the motors, the
// Arduino could be connected to the computer running ROS listening
// for serial commands.  This 'motor' node could then output whatever
// command the Arduino was expecting to move forward.

done(error)
})
})

// ROS comes with several command-line tools like rosmsg and rostopic.
// Rostopic can be used to debug messages by publishing or subscribing to
// topics. Rostopic is used here to publish a geometry_msgs/Twist message
// over the topic 'cmd_vel' in order to test the subscribing node.
var publishCommand = 'rostopic'
+ ' pub'
+ ' /cmd_vel'
+ ' geometry_msgs/Twist'
+ &quot; '{linear:  {x: 1.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}'&quot;
var child = exec(publishCommand, function(error, stdout, stderr) {
should.not.exist(error)
})
})</code></pre></dd>
    </dl>
  </section>
</article>

<article id="how-to-web-server">
  <section class="suite">
    <h1>How to turn your robot into a web server</h1>
    <dl>
    <dt>create a package</dt>
    <dd><pre><code class="javascript">
// After installing ROS, creating a new rosnodejs project is similar to creating
// any new ROS package.
    </code></pre></dd>
    </dl>
  </section>
</article>

<article id="how-to-web-app">
  <section class="suite">
    <h1>How to create a telepresence web app</h1>
    <dl>
    <dt>create a package</dt>
    <dd><pre><code class="javascript">
// After installing ROS, creating a new rosnodejs project is similar to creating
// any new ROS package.
    </code></pre></dd>
    </dl>
  </section>
</article>

</div>

<footer class="footer">
  <div class="container">
    <p>
      CD, gears, heart, laptop, robot, and wrench symbols are from <a
        href="http://thenounproject.com" title="The Noun Project">The Noun
        Project</a>.
    </p>
  </div>
</footer>

</body>
</html>
